<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Miku AR - Debug Version</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <style>
        body { margin: 0; background-color: #000; color: white; font-family: sans-serif; overflow: hidden; }
        
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        
        canvas { position: absolute; left: 0; top: 0; z-index: 1; }
        video { position: absolute; left: 0; top: 0; z-index: 0; display: none; } /* 隱藏原始 video */

        /* 介面 UI */
        #ui-layer { position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        
        h1 { margin: 0; color: #39C5BB; text-shadow: 0 0 5px #39C5BB; font-size: 24px; background: rgba(0,0,0,0.5); display: inline-block; padding: 5px 10px; border-radius: 10px; }
        
        #status { background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 8px; font-size: 14px; color: #fff; max-width: 90%; word-wrap: break-word; }

        /* 開始按鈕 (置中) */
        #startBtn { 
            pointer-events: auto; 
            background: #39C5BB; 
            color: white; 
            border: none; 
            padding: 15px 40px; 
            font-size: 20px; 
            border-radius: 30px; 
            box-shadow: 0 0 15px #39C5BB;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            cursor: pointer;
        }
        #startBtn:active { transform: translate(-50%, -50%) scale(0.95); }
    </style>
</head>
<body>

    <div id="container">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="output"></canvas>
        
        <div id="ui-layer">
            <h1>MIKU AR SYSTEM</h1>
            <div id="status">等待使用者啟動...</div>
        </div>
        
        <button id="startBtn" onclick="startApp()">點擊開始 (Start)</button>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('output');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        let net;
        let isRunning = false;

        function log(msg) {
            statusDiv.innerHTML = msg;
            console.log(msg);
        }

        async function startApp() {
            startBtn.style.display = 'none'; // 隱藏按鈕
            log("正在初始化... 請允許攝影機權限");

            try {
                // 1. 設定攝影機
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: { facingMode: 'user', width: 640, height: 480 }
                });
                video.srcObject = stream;
                
                // 等待影片載入
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                // 設定 Canvas 尺寸
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                log("攝影機已啟動。正在下載 AI 模型 (首次需 10-20 秒)...");

                // 2. 載入模型 (使用更輕量的設定)
                net = await posenet.load({
                    architecture: 'MobileNetV1',
                    outputStride: 16,
                    inputResolution: { width: 320, height: 240 }, // 降低解析度以加速
                    multiplier: 0.5 // 降低乘數以加速 (0.5 最快)
                });

                log("系統啟動完成！可開啟飛航模式 (Offline Mode Ready)");
                isRunning = true;
                detectFrame();

            } catch (err) {
                log("<span style='color:red'>錯誤: " + err.message + "<br>請確認網址是 https 或 localhost</span>");
                startBtn.style.display = 'block'; // 顯示按鈕讓使用者重試
                startBtn.innerText = "重試 (Retry)";
            }
        }

        async function detectFrame() {
            if (!isRunning) return;

            // 調整 Canvas 繪圖比例
            const videoRatio = video.videoWidth / video.videoHeight;
            const screenRatio = canvas.width / canvas.height;
            let drawWidth, drawHeight, startX, startY;

            if (screenRatio > videoRatio) {
                drawWidth = canvas.width;
                drawHeight = canvas.width / videoRatio;
                startX = 0;
                startY = (canvas.height - drawHeight) / 2;
            } else {
                drawHeight = canvas.height;
                drawWidth = canvas.height * videoRatio;
                startX = (canvas.width - drawWidth) / 2;
                startY = 0;
            }

            // 繪製影像背景 (鏡像)
            ctx.save();
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, startX, startY, drawWidth, drawHeight);
            ctx.restore();

            // AI 偵測
            const pose = await net.estimateSinglePose(video, { flipHorizontal: false });

            // 繪製 Miku 雙馬尾
            drawAugmentedReality(pose.keypoints, startX, startY, drawWidth, drawHeight);

            requestAnimationFrame(detectFrame);
        }

        function drawAugmentedReality(keypoints, sx, sy, dw, dh) {
            // 座標轉換函式 (因為 Canvas 有縮放，需要把 AI 的座標轉成螢幕座標)
            // 注意：因為我們將畫面做了鏡像翻轉，X 軸計算要小心
            const mapX = (x) => canvas.width - (sx + (x / video.videoWidth) * dw); 
            const mapY = (y) => sy + (y / video.videoHeight) * dh;

            const leftEar = keypoints.find(k => k.part === 'leftEar');
            const rightEar = keypoints.find(k => k.part === 'rightEar');

            if (leftEar && rightEar && leftEar.score > 0.4 && rightEar.score > 0.4) {
                const lx = mapX(leftEar.position.x);
                const ly = mapY(leftEar.position.y);
                const rx = mapX(rightEar.position.x);
                const ry = mapY(rightEar.position.y);

                // 計算頭部參數
                const earDist = Math.hypot(lx - rx, ly - ry); // 兩耳距離
                const angle = Math.atan2(ry - ly, rx - lx); // 頭部傾斜角度

                // 開始繪圖
                ctx.save();
                
                // 1. 設定雙馬尾樣式
                ctx.fillStyle = "rgba(57, 197, 187, 0.7)"; // Miku Green 半透明
                ctx.strokeStyle = "#39C5BB";
                ctx.lineWidth = 3;

                // 2. 繪製左馬尾 (在畫面右邊，因為鏡像)
                drawPigtail(ctx, lx, ly, earDist, angle, -1);
                // 3. 繪製右馬尾
                drawPigtail(ctx, rx, ry, earDist, angle, 1);

                ctx.restore();
            }
        }

        function drawPigtail(ctx, x, y, size, angle, dir) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle); // 跟隨頭部旋轉
            
            const w = size * 0.8; 
            const h = size * 5.0; // 馬尾長度

            ctx.beginPath();
            ctx.moveTo(0, 0);
            // 貝茲曲線畫馬尾
            ctx.bezierCurveTo(
                dir * w * 2, h * 0.2, 
                dir * w * 0.5, h * 0.8, 
                dir * w, h
            );
            ctx.bezierCurveTo(
                dir * w * -0.2, h * 0.8, 
                dir * w * 0.8, h * 0.2, 
                0, 0
            );
            ctx.fill();
            ctx.stroke();

            // 髮飾
            ctx.fillStyle = "#E1008D"; // Magenta
            ctx.fillRect(dir === 1 ? -5 : -15, -10, 20, 20);

            ctx.restore();
        }
    </script>
</body>
</html>
